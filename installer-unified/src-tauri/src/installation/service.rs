// Service installation/management helpers
//
// Phase 5: Installation Logic (Windows + Linux)

use anyhow::{Context, Result};
use log::{debug, info, warn};
use std::path::{Path, PathBuf};
use std::time::Instant;
use tokio::time::Duration;

use crate::installation::run_cmd_with_timeout;

/// Placeholder service module.
///
/// The plan requires:
/// - Windows service install via `sc.exe` or PowerShell
/// - Linux service install via systemd (`systemctl`)
///
/// We implement incrementally as installation endpoints are wired up.
#[allow(dead_code)]
pub async fn service_placeholder() -> Result<()> {
    Ok(())
}

/// Write a Windows service install/start placeholder script.
///
/// This is used when runtime/service wiring is not yet available at build-time,
/// but we still want deterministic artifacts for support and validation.
pub async fn write_windows_service_install_script(
    artifacts_dir: &Path,
    service_name: &str,
    exe_path: &Path,
) -> Result<PathBuf> {
    let started = Instant::now();
    debug!(
        "[PHASE: installation] [STEP: service] write_windows_service_install_script entered (service_name={}, exe_path={:?})",
        service_name, exe_path
    );

    tokio::fs::create_dir_all(artifacts_dir).await?;
    let path = artifacts_dir.join("install_windows_service.ps1");
    let exe_str = exe_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid exe path"))?;

    let content = format!(
        r#"# CADalytix Windows Service Install Placeholder (Phase 5)
# This script is generated by the unified installer for support/verification.
# It is NOT executed automatically unless service wiring is enabled.

$ErrorActionPreference = "Stop"

$serviceName = "{service_name}"
$exePath = "{exe_str}"

Write-Host "Installing service $serviceName from $exePath"

# Create / update service
sc.exe stop $serviceName | Out-Null
sc.exe delete $serviceName | Out-Null

sc.exe create $serviceName binPath= "`"$exePath`"" start= auto DisplayName= "CADalytix" | Out-Null

# Start service
sc.exe start $serviceName | Out-Null

Write-Host "Service started."
"#,
        service_name = service_name,
        exe_str = exe_str.replace('"', "`\"")
    );

    tokio::fs::write(&path, content)
        .await
        .with_context(|| format!("Failed to write {:?}", path))?;

    debug!(
        "[PHASE: installation] [STEP: service] write_windows_service_install_script exit (path={:?}, duration_ms={})",
        path,
        started.elapsed().as_millis()
    );
    Ok(path)
}

/// Write Linux systemd service placeholder unit.
pub async fn write_linux_systemd_service_unit(
    artifacts_dir: &Path,
    service_name: &str,
    exec_path: &Path,
) -> Result<PathBuf> {
    let started = Instant::now();
    debug!(
        "[PHASE: installation] [STEP: service] write_linux_systemd_service_unit entered (service_name={}, exec_path={:?})",
        service_name, exec_path
    );

    tokio::fs::create_dir_all(artifacts_dir).await?;
    let path = artifacts_dir.join("cadalytix.service");
    let exec_str = exec_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid exec path"))?;

    let content = format!(
        r#"# CADalytix systemd service placeholder (Phase 5)
[Unit]
Description=CADalytix
After=network.target

[Service]
Type=simple
ExecStart={exec_str}
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
"#,
        exec_str = exec_str
    );

    tokio::fs::write(&path, content)
        .await
        .with_context(|| format!("Failed to write {:?}", path))?;

    debug!(
        "[PHASE: installation] [STEP: service] write_linux_systemd_service_unit exit (path={:?}, duration_ms={})",
        path,
        started.elapsed().as_millis()
    );
    Ok(path)
}

/// Install/start and verify a Windows service using `sc.exe`.
///
/// This requires elevated permissions. Caller should handle/report failures cleanly.
#[cfg(windows)]
pub async fn install_and_start_windows_service(service_name: &str, exe_path: &Path) -> Result<()> {
    let started = Instant::now();
    debug!(
        "[PHASE: installation] [STEP: service] install_and_start_windows_service entered (service_name={}, exe_path={:?})",
        service_name, exe_path
    );

    let exe_str = exe_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid exe path"))?;

    // Best-effort stop/delete (ignore failures if service doesn't exist).
    let _ = run_cmd_with_timeout(
        "sc.exe",
        &["stop".to_string(), service_name.to_string()],
        Duration::from_secs(20),
        "sc_stop",
    )
    .await;
    let _ = run_cmd_with_timeout(
        "sc.exe",
        &["delete".to_string(), service_name.to_string()],
        Duration::from_secs(20),
        "sc_delete",
    )
    .await;

    // Create service (note sc.exe requires a space after '=' so we pass `binPath=` then a value arg).
    let create_args = vec![
        "create".to_string(),
        service_name.to_string(),
        "binPath=".to_string(),
        format!("\"{}\"", exe_str),
        "start=".to_string(),
        "auto".to_string(),
        "DisplayName=".to_string(),
        "\"CADalytix\"".to_string(),
    ];
    let out =
        run_cmd_with_timeout("sc.exe", &create_args, Duration::from_secs(30), "sc_create").await?;
    if out.exit_code != Some(0) {
        warn!(
            "[PHASE: installation] [STEP: service] sc.exe create failed (exit_code={:?}) stderr={}",
            out.exit_code, out.stderr
        );
        anyhow::bail!(
            "Windows service creation failed (exit_code={:?})",
            out.exit_code
        );
    }

    let out = run_cmd_with_timeout(
        "sc.exe",
        &["start".to_string(), service_name.to_string()],
        Duration::from_secs(30),
        "sc_start",
    )
    .await?;
    if out.exit_code != Some(0) {
        warn!(
            "[PHASE: installation] [STEP: service] sc.exe start failed (exit_code={:?}) stderr={}",
            out.exit_code, out.stderr
        );
        anyhow::bail!(
            "Windows service start failed (exit_code={:?})",
            out.exit_code
        );
    }

    let running = is_windows_service_running(service_name).await?;
    if !running {
        anyhow::bail!("Windows service is not running after start");
    }

    info!(
        "[PHASE: installation] [STEP: service] install_and_start_windows_service exit ok (service_name={}, duration_ms={})",
        service_name,
        started.elapsed().as_millis()
    );
    Ok(())
}

#[cfg(windows)]
pub async fn is_windows_service_running(service_name: &str) -> Result<bool> {
    let started = Instant::now();
    debug!(
        "[PHASE: installation] [STEP: service] is_windows_service_running entered (service_name={})",
        service_name
    );

    let out = run_cmd_with_timeout(
        "sc.exe",
        &["query".to_string(), service_name.to_string()],
        Duration::from_secs(20),
        "sc_query",
    )
    .await?;

    // `sc query` returns non-zero if service doesn't exist.
    if out.exit_code != Some(0) {
        warn!(
            "[PHASE: installation] [STEP: service] sc.exe query failed (exit_code={:?}) stderr={}",
            out.exit_code, out.stderr
        );
        return Ok(false);
    }

    let running = out.stdout.to_ascii_uppercase().contains("RUNNING");
    debug!(
        "[PHASE: installation] [STEP: service] is_windows_service_running exit (running={}, duration_ms={})",
        running,
        started.elapsed().as_millis()
    );
    Ok(running)
}
